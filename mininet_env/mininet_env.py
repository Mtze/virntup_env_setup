from mininet.net import Mininet
from mininet.topo import Topo
from mininet.cli import CLI

from p4_mininet import P4Host
from p4runtime_switch import P4RuntimeSwitch

from mininet.log import setLogLevel, error
import logging
import json
import os
import argparse

PCAP_PATH = "pcap_dump"

"""
The code in this file is heavily inspired from the [p4lang/tutorial](https://github.com/p4lang/tutorials) 
ExerciseRunner. It was adapted and heavily simplified to fit the needs of this project.
"""
# Enable debug logging here
# logging.basicConfig(level=logging.DEBUG)
# setLogLevel("debug")


class VirntupSwitch(P4RuntimeSwitch):
    """VirntupSwitch.
    This is just a wrapper class for the `P4RuntimeSwitch` provided by the `p4runtime_switch` library.
    We need this class to set the correct bmv2 binary in advance, as Mininet needs a Switch-class
    to instantiate mininet switches with custom implementations. As the switch binary is optinal in 
    the library we have to wrapp the class to set the binary.
    """

    def __init__(self, name, **opts):
        """__init__.

        Parameters
        ----------
        name :
            string - Name of the switch - Handed over to the P4RuntimeSwitch class
        opts :
            opts - See `P4RuntimeSwitch` implementation for more detail
        """

        super().__init__(name,
                         sw_path='simple_switch_grpc',
                         pcap_dump=PCAP_PATH,
                         **opts)


class VirntupTopo(Topo):
    """VirntupTopo.

    We have to instantiate the Topology in mininet. This class generates one P4Switch, accessible
    via P4Runtime and configures it as defined in the environment file the class gets as argument
    """

    def __init__(self, env, host):
        """__init__.

        Parameters
        ----------
        env:
            dictionary containing the `env.json` configuration
        host:
            dictionary containing the `host.json` configuration
        """
        super().__init__(self)

        # Add "physical" P4 switch to topology
        self.switch_name = "s1"
        # Here we specify the Wrapper class as Switch type
        self.addSwitch(self.switch_name, cls=VirntupSwitch)

        # Add hosts from env file to the topology

        host_links = env["host_links"]
        links = env["links"]

        for link in host_links:
            # Iterate over all host_links, and add them to the network

            host_name = link[0]
            sw_port = link[1]

            # Check the hosts from the env file is needed by the topo. 
            # The host config specifies all used hosts.
            if host_name in host.keys():
                self.addHost(host_name)
                self.addLink(host_name, self.switch_name, port2=sw_port)
            

        # Add loops between defined ports

        for link in links:
            self.addLink(self.switch_name, self.switch_name, link[0], link[1])


class VirntupEnv:
    """VirntupEnv.

    Virntup BMv2 Environment setup. This class allows to instantiate a Virntup environment
    using mininet and the bmv2 simple_switch_grpc binary. This class is used to generate the 
    topology from an env file and is used to interact with it. 
    """

    def __init__(self, env_json_fd, host_json_fd):
        """__init__.

        Init only creates the mininet configuration, to start the network use the 
        `start()` method on the object. 

        Parameters
        ----------
        env_json_fd :
            file descriptor to the `env.json` file which contains the desired switch environment
        host_json_fd :
            file descriptor to the `host.json` file which was generated by virntup and represents 
            the desired configuration of attached hosts.
        """

        self.env_json_fd = env_json_fd
        self.env_json = json.load(env_json_fd)

        self.host_json_fd = host_json_fd
        self.host_json = json.load(host_json_fd)

        self.topo = VirntupTopo(self.env_json, self.host_json)
        self.net = Mininet(topo=self.topo,
                           host=P4Host,
                           controller=None)

        if not os.path.exists(PCAP_PATH):
            try:
                os.mkdir(PCAP_PATH)
            except OSError:
                error("Cannot create pcap_dump directory")

    def start(self):
        """start.

        Start mininet and open the mininet CLI 
        """

        # Open the host configuration file and make it accessable

        # Start the mininet network
        self.net.start()

        # Iterate over hosts in configuration files and update the configration
        # of the hosts (which are already added to the network) according to
        # the settings in the configuration file.
        for host in self.host_json:

            tmp_host = self.net.getNodeByName(host)
            tmp_host.setIP(self.host_json[host]['ip'])
            tmp_host.setMAC(self.host_json[host]['mac'])

            # Add default route to the only connected interface eth0
            tmp_host.cmd('route add default dev eth0')
            for inner_host in self.host_json:
                # Now we need to update the ARP table. As we dont have ARP in place
                # all hosts have a global view (know all MAC addresses in the network).
                # To do this, we need to iterate over the host config file again and
                # optain all the IP-MAC address pairs and add them in each host.
                mac = str(self.host_json[inner_host]['mac'])

                # We need to remove the CIDR from the ip config to add it to the ARP table
                ip = str(self.host_json[inner_host]['ip'].split('/')[0]) 
                tmp_host.cmd('arp -i eth0 -s ' + ip + ' ' + mac)

        CLI(self.net)


def main():
    """main.
    """
    parser = argparse.ArgumentParser(
        description="Virntup BMv2 target setup helper. This script creates a virtual representation that can be used to test virntup deployments"
    )

    parser.add_argument(
        '--debug',
        action='store_true',
        help='Print Debug log'
    )

    parser.add_argument(
        '--info',
        action='store_true',
        help='Print Info log'
    )

    parser.add_argument(
        '--env',
        type=argparse.FileType('r'),
        default='env.json',
        required=True,
        help="Path to the env.json file in which the enviroment is confitured - Default is `env.json`"
    )

    parser.add_argument(
        '--host',
        type=argparse.FileType('r'),
        default='host.json',
        required=True,
        help='Path to the host.json file which was created by virtup - Default is `host.json`'
    )

    args = parser.parse_args()

    if args.debug:
        logging.basicConfig(level=logging.DEBUG)

    if args.info:
        logging.basicConfig(level=logging.INFO)

    logging.debug(
        "program called with the following arguments: {}".format(args))

    ve = VirntupEnv(args.env, args.host)
    ve.start()



if __name__ == '__main__':
    main()
